#Дневник разработки

##Принятые решения:
1. FastApi + websockets
2. Рендерим сцену (Ходим) 30 раз в секунду.
3. Пусть экран будет 400х400 px
4. Размер платформы подбираю кажется будет что-то около 80х10 px
5. Пускай игроки не могут менять свой пад.
6. Пускай мяч будет 10х10 px
7. Пускай управление стрелками, а запуск мяча Enter.
8. Я решил упростить и не считать кривизну по формуле, а просто прикидывать.
9. Я решил, что для простоты тот кто последний дотронулся до мяча, тот и получает очко


##TODO: сделать понг
-1. Поднять rest api-
-2. Рендерить сцену для одного-
-3. Научить принимать нажатые клавиши-
-4. Начать их считать и рендерить картинку-
-5. Поднять виртуалку для тестирования-
-6. Научиться рулить двумя ракетками-
-7. Адекватно сохранять количество вошедших игроков-
-8. Рассчитать мяч (прямой)-
-9. Рассчитать столкновения-
-10. Перезагрузка мяча-
-11. Вести счет-
-12. Рассчитать мяч углы-

##Мои размышления
1. Первая мысль, надо ходить в апи 30 раз в секунду и рендерить сцену
2. Для этих целей restapi не подойдет. Потому что будет порядка 30 * 4 = 120 rps
3. Значит нужно делать на websockets
4. Теперь нужен render
5. Не забыть про timestamp от сообщений (А нужен ли он мне?)
6. Как хранить состояние системы? Кажется можно здорово сэкономить, если резделить мяч и платформы по разным каналам
7. Движение мяча я вынес на отдельный рендер, чтобы просто слать туда состояние системы.
8. Хорошо бы конечно все привязать к параметрам, размер пада, размер мяча, размер площадки.
9. Увидел проблему, от количества игроков, мяч начинает двигаться быстрее, нужно убрать move_ball из сокета.
В итоге Я тут немного схитрил, и сделал скорость зависимой от количества соединений :)
10. Пару багов надо пофиксить связанных с перезагрузкой/выходом игрока с прикрепленным мячом
11. Начинаю думать что нужно выкатить на виртуальную машину и начинать оформлять